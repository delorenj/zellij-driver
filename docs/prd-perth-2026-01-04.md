# Product Requirements Document: Perth

**Date:** 2026-01-04
**Author:** delorenj
**Version:** 1.0
**Project Type:** Cognitive Context Management Tool
**Project Level:** Level 3
**Status:** Draft

---

## Document Overview

This Product Requirements Document (PRD) defines the functional and non-functional requirements for Perth (formerly zellij-driver). It serves as the source of truth for what will be built and provides traceability from requirements through implementation.

**Related Documents:**
- Implementation Plan: `INTENT_TRACKING_IMPLEMENTATION_PLAN.md`
- Conversation Summary: `CONVERSATION_SUMMARY_INTENT_TRACKING.md`
- Rebranding Plan: `REBRANDING_PLAN.md`
- v1.0 PRD: `PRD.md` (navigation primitives baseline)

---

## Executive Summary

Perth is a cognitive context manager for Zellij terminal multiplexer sessions that transforms terminal workspaces from simple process containers into persistent cognitive environments. Built on a Redis-backed state architecture, Perth provides pane-first navigation primitives (v1.0) and introduces intent history tracking (v2.0) to capture **what you were working on**, not just **what commands you ran**.

The system addresses the critical gap between granular shell history (too much noise) and abstract git commits (code-focused, non-linear). Perth stores work narratives as linear intent histories per pane, enabling instant context recovery after interruptions, seamless agent continuity in multi-agent workflows, and team coordination through shared cognitive state.

**Core Innovation:** Version control for human intent, not code artifacts. Git tracks code state; Perth tracks work state.

**Primary Use Cases:**
1. Solo developers resuming work after context switches
2. AI agents maintaining continuity across session boundaries (Jelmore integration)
3. Team handoffs with preserved cognitive context
4. Multi-agent coordination in 33GOD ecosystem workflows

---

## Product Goals

### Business Objectives

1. **Reduce Cognitive Load During Context Recovery**
   - Eliminate manual reconstruction of "where was I?" after interruptions
   - Provide instant narrative summary of previous work session
   - Target: <10 seconds to resume productive work (vs. 2-5 minutes currently)

2. **Enable Seamless Session Resumption with Minimal Context-Switching Delay**
   - Preserve intent across Zellij restarts, tab closures, system reboots
   - Linear narrative history independent of git branches
   - Support for non-code work (installations, config, debugging)

3. **Provide AI Agents with Narrative History for Continuity**
   - Enable Jelmore-spawned agents to query previous session context
   - Automatic checkpoint recording during agent work
   - Context injection for agent resumption after failures/pauses

4. **Transform Terminal Sessions from Process Containers to Cognitive Workspaces**
   - Shift mental model: panes are persistent workspaces with memory
   - Make session state transparent and recoverable
   - Enable observability into distributed team workflows

### Success Metrics

**Adoption:**
- 50% of znav users enable intent tracking within 3 months of v2.0 release
- Average 10+ intent entries per active pane across user base
- 100% of Jelmore agent sessions use intent tracking

**Quality:**
- >80% of automated summaries rated "useful" by users
- <5% of summaries require manual correction
- Context recovery accuracy >90% (users resume work without confusion)

**Performance:**
- <100ms latency for history queries (p95)
- <$5/month LLM costs per power user (50 snapshots/day)
- No measurable shell performance degradation from hooks

**Integration:**
- Jelmore adopts intent tracking for all agent sessions within 1 month of v2.0
- Holocene dashboard displays session timelines within 2 months
- 3+ Yi agents actively leverage intent history for task coordination

---

## Functional Requirements

Functional Requirements (FRs) define **what** the system does - specific features and behaviors.

Each requirement includes:
- **ID**: Unique identifier (FR-001, FR-002, etc.)
- **Priority**: Must Have / Should Have / Could Have / Won't Have (MoSCoW)
- **Description**: What the system should do
- **Acceptance Criteria**: How to verify it's complete

---

### FR-001: Manual Intent Logging

**Priority:** Must Have

**Description:**
Users can manually record intent summaries for panes via CLI command `znav pane log <pane_name> <summary>`. Summaries are stored in Redis and retrievable as linear history.

**Acceptance Criteria:**
- [ ] Command `znav pane log backend-dev "Integrated OAuth library"` succeeds
- [ ] Summary stored in `perth:pane:backend-dev:history` Redis key
- [ ] Latest summary updates `perth:pane:backend-dev` hash field `last_intent`
- [ ] Command completes in <50ms (p95)
- [ ] Invalid pane names return helpful error messages

**Dependencies:** FR-021 (Redis-backed state)

---

### FR-002: Intent History Retrieval

**Priority:** Must Have

**Description:**
Users can query full intent history for a pane via `znav pane history <pane_name>`. Output displays chronologically ordered summaries with timestamps.

**Acceptance Criteria:**
- [ ] Command `znav pane history backend-dev` returns all entries
- [ ] Default output format is human-readable text (timestamps + summaries)
- [ ] Entries ordered newest-first
- [ ] Empty history returns friendly message, not error
- [ ] Command completes in <100ms (p95)

**Dependencies:** FR-001

---

### FR-003: Intent Entry Classification

**Priority:** Must Have

**Description:**
Intent entries support type classification (milestone, checkpoint, exploration) via `--type` flag. Type affects visualization and filtering in later phases.

**Acceptance Criteria:**
- [ ] Flag `--type milestone` sets entry type to "milestone"
- [ ] Flag `--type checkpoint` sets entry type to "checkpoint"
- [ ] Flag `--type exploration` sets entry type to "exploration"
- [ ] Default type is "checkpoint" if not specified
- [ ] Invalid types return error with valid options listed

**Dependencies:** FR-001

---

### FR-004: Artifact Tracking

**Priority:** Should Have

**Description:**
Intent entries can attach file paths via `--artifacts` flag to associate code changes with intent. Artifacts stored in entry metadata.

**Acceptance Criteria:**
- [ ] Flag `--artifacts file1.py file2.js` attaches both files to entry
- [ ] Artifact paths stored in intent entry JSON
- [ ] History output displays artifacts per entry
- [ ] Relative paths resolved to absolute paths
- [ ] Non-existent files allowed (for deleted files)

**Dependencies:** FR-001

---

### FR-005: Multiple Output Formats

**Priority:** Must Have

**Description:**
Intent history supports both human-readable text (default) and machine-readable JSON (`--format json`) for scripting integration.

**Acceptance Criteria:**
- [ ] Default output is formatted text with timestamps
- [ ] Flag `--format json` returns valid JSON array
- [ ] JSON includes all entry fields (timestamp, summary, type, artifacts, source)
- [ ] JSON parseable by `jq`, Python `json.loads()`, etc.
- [ ] Invalid format values return error

**Dependencies:** FR-002

---

### FR-006: LLM-Powered Auto-Summarization

**Priority:** Should Have

**Description:**
Command `znav pane snapshot <pane_name>` analyzes recent shell history and git diff, generates intent summary via LLM, stores as automated entry.

**Acceptance Criteria:**
- [ ] Command collects last 20 shell commands from history
- [ ] Command runs `git diff --stat` if pane is in git repo
- [ ] LLM receives prompt with shell commands and git diff
- [ ] Generated summary stored with `source: automated`
- [ ] Command completes in <3s (p95)
- [ ] Graceful failure if LLM unavailable (error message, no crash)

**Dependencies:** FR-001, NFR-004 (secret filtering)

---

### FR-007: Shell Hook Integration

**Priority:** Should Have

**Description:**
Optional shell hook triggers automatic snapshots every N commands. Configurable via `~/.config/perth/config.toml`.

**Acceptance Criteria:**
- [ ] Zsh precmd hook invokes `znav pane snapshot` periodically
- [ ] Config setting `auto_snapshot_interval` controls trigger (default: 10 commands)
- [ ] Hook runs asynchronously (no blocking)
- [ ] Hook disabled if `intent_tracking.enabled = false`
- [ ] Hook errors logged, do not crash shell

**Dependencies:** FR-006

---

### FR-008: Secret Pattern Filtering

**Priority:** Must Have (for LLM features)

**Description:**
Before submitting shell history to LLM, system filters patterns matching secrets (passwords, API keys, tokens). Configurable regex patterns in config.

**Acceptance Criteria:**
- [ ] Patterns `password=`, `token=`, `key=`, `secret=` filtered by default
- [ ] Config file allows custom regex patterns
- [ ] Filtered content replaced with `[REDACTED]`
- [ ] Warning logged when filters trigger
- [ ] Filter disabled if `privacy.filter_secrets = false`

**Dependencies:** FR-006

---

### FR-009: Local Model Fallback

**Priority:** Should Have

**Description:**
If Claude API unavailable or user prefers privacy, system supports local LLM (Ollama, llama.cpp) as fallback provider.

**Acceptance Criteria:**
- [ ] Config `llm_provider = "local"` uses local model
- [ ] Local model endpoint configurable (`llm_local_url`)
- [ ] Graceful degradation if local model fails (manual logging still works)
- [ ] Warning if local model returns low-quality summaries
- [ ] Automatic fallback: Claude → local → manual-only

**Dependencies:** FR-006

---

### FR-010: Configurable Snapshot Triggers

**Priority:** Should Have

**Description:**
Auto-snapshot behavior configurable: command-based (every N commands), time-based (every N minutes), or manual-only.

**Acceptance Criteria:**
- [ ] Config `snapshot_trigger = "commands"` uses command count
- [ ] Config `snapshot_trigger = "time"` uses time interval
- [ ] Config `snapshot_trigger = "manual"` disables auto-snapshots
- [ ] Command count threshold configurable (`auto_snapshot_interval`)
- [ ] Time interval configurable (`auto_snapshot_minutes`)

**Dependencies:** FR-006, FR-007

---

### FR-011: Context Recovery API

**Priority:** Should Have

**Description:**
Command `znav pane history <pane_name> --format context` returns formatted narrative suitable for agent prompt injection.

**Acceptance Criteria:**
- [ ] Output format optimized for LLM consumption
- [ ] Includes chronological narrative of work
- [ ] Highlights last checkpoint and current goal
- [ ] Suggests next steps based on history
- [ ] Max 1000 tokens for context window efficiency

**Dependencies:** FR-002, FR-005

---

### FR-012: Bloodbank Event Publishing

**Priority:** Should Have

**Description:**
Milestone-type intent entries trigger Bloodbank events for ecosystem integration (e.g., Holocene notifications).

**Acceptance Criteria:**
- [ ] Milestones publish to `perth.milestone.recorded` event topic
- [ ] Event payload includes pane name, summary, timestamp, artifacts
- [ ] Publishing async (does not block `znav` command)
- [ ] Failed publishes logged, do not fail command
- [ ] Disabled if Bloodbank unavailable

**Dependencies:** FR-003 (milestones), external Bloodbank service

---

### FR-013: Agent Checkpoint Recording

**Priority:** Should Have

**Description:**
Agents can record checkpoints via `--source agent` flag to distinguish automated agent work from human work.

**Acceptance Criteria:**
- [ ] Flag `--source agent` sets entry source to "agent"
- [ ] Agent checkpoints visually distinct in history output
- [ ] Source field queryable for filtering agent-only history
- [ ] Jelmore wrapper supports agent checkpoint recording
- [ ] Agent source cannot be spoofed by users (validation)

**Dependencies:** FR-001

---

### FR-014: Session Resumption Context

**Priority:** Should Have

**Description:**
When navigating to existing pane, system optionally displays last intent as reminder of previous session state.

**Acceptance Criteria:**
- [ ] Command `znav pane backend-dev` prints last intent to stdout
- [ ] Display configurable (`show_last_intent = true|false`)
- [ ] Display non-intrusive (single line, color-coded)
- [ ] Display includes timestamp of last entry
- [ ] Display skipped if no history exists

**Dependencies:** FR-002

---

### FR-015: Semantic Search

**Priority:** Could Have

**Description:**
Command `znav search "<query>"` performs semantic search across all intent histories using vector embeddings. Returns ranked results.

**Acceptance Criteria:**
- [ ] Query embedded using same model as summaries
- [ ] Results ranked by cosine similarity
- [ ] Output shows pane name, matching entry, similarity score
- [ ] Cross-pane search across entire workspace
- [ ] Configurable result limit (default: 10)

**Dependencies:** FR-002, vector database integration (Qdrant/Chroma)

---

### FR-016: Goal State Tracking

**Priority:** Could Have

**Description:**
Panes support optional goal declarations. System estimates progress toward goal based on intent history and milestones.

**Acceptance Criteria:**
- [ ] Command `znav pane goal <pane_name> "Add user authentication"` sets goal
- [ ] Progress estimation based on milestone count and frequency
- [ ] Command `znav pane progress <pane_name>` shows % complete estimate
- [ ] Goal shown in `znav list` tree view
- [ ] Goal editable and removable

**Dependencies:** FR-003 (milestones)

---

### FR-017: Pattern Recognition

**Priority:** Could Have

**Description:**
System analyzes intent histories to identify recurring work patterns (e.g., "debugging OAuth" appears frequently) and suggests optimizations.

**Acceptance Criteria:**
- [ ] Weekly pattern analysis runs automatically
- [ ] Patterns identified via clustering or LLM analysis
- [ ] Suggestions surfaced in `znav insights` command
- [ ] Patterns include: common blockers, frequent task types, typical duration
- [ ] Insights exportable for team retrospectives

**Dependencies:** FR-002, sufficient history data (30+ entries)

---

### FR-018: Dashboard Visualization

**Priority:** Could Have

**Description:**
Holocene dashboard displays session timelines with intent history rendered as interactive timeline widget.

**Acceptance Criteria:**
- [ ] Timeline shows entries chronologically with timestamps
- [ ] Milestones visually distinct from checkpoints
- [ ] Click on entry shows full summary and artifacts
- [ ] Filter by date range, pane, type
- [ ] Real-time updates via Bloodbank events

**Dependencies:** FR-002, FR-012, Holocene dashboard integration

---

### FR-019: Export to Markdown/Obsidian

**Priority:** Could Have

**Description:**
Command `znav pane export <pane_name>` generates Markdown file with formatted intent history for journaling or documentation.

**Acceptance Criteria:**
- [ ] Output valid Markdown with headers, lists, timestamps
- [ ] Obsidian-compatible YAML frontmatter
- [ ] Artifacts rendered as file links
- [ ] Configurable template for export format
- [ ] Export to stdout or file (`--output` flag)

**Dependencies:** FR-002

---

### FR-020: Pane-First Navigation (v1.0)

**Priority:** Must Have

**Description:**
Command `znav pane <pane_name>` creates or navigates to named pane. If pane exists, focuses it. If not, creates in current tab.

**Acceptance Criteria:**
- [x] Creating new pane succeeds
- [x] Navigating to existing pane focuses it
- [x] Position-based auto-focus works
- [x] Tab can be specified via `--tab` flag
- [x] Metadata attached via `--meta` flags

**Status:** Implemented in v1.0

---

### FR-021: Redis-Backed State Persistence (v1.0)

**Priority:** Must Have

**Description:**
All pane metadata stored in Redis with keyspace `perth:pane:<name>`. State survives Zellij restarts.

**Acceptance Criteria:**
- [x] Pane metadata persists across restarts
- [x] Redis connection configurable via env var or config file
- [x] Redis failures logged, do not crash znav
- [x] State reconciliation command available

**Status:** Implemented in v1.0

---

### FR-022: Auto-Focus via Position Tracking (v1.0)

**Priority:** Must Have

**Description:**
System tracks pane positions as `meta:position`. When navigating, auto-focuses target pane using sequential `focus-next-pane` actions.

**Acceptance Criteria:**
- [x] Position stored during pane creation
- [x] Focus navigation works in tabs with 2-10 panes
- [x] Edge cases handled (position no longer exists)

**Status:** Implemented in v1.0

---

### FR-023: Metadata Attachment (v1.0)

**Priority:** Must Have

**Description:**
Arbitrary key-value metadata attachable to panes via `--meta key=value` flags. Metadata queryable via `znav pane info`.

**Acceptance Criteria:**
- [x] Multiple `--meta` flags supported
- [x] Metadata persisted in Redis
- [x] Metadata displayed in tree view
- [x] Reserved keys prevented (`session`, `tab`, `position`)

**Status:** Implemented in v1.0

---

### FR-024: Reconciliation (v1.0)

**Priority:** Must Have

**Description:**
Command `znav reconcile` syncs Redis state with actual Zellij layout. Marks stale panes (closed but still in Redis).

**Acceptance Criteria:**
- [x] Reconciliation detects closed panes
- [x] Stale panes marked with `status: stale`
- [x] Reconciliation safe to run repeatedly (idempotent)
- [x] Summary output shows changes made

**Status:** Implemented in v1.0

---

### FR-025: Tree Visualization (v1.0)

**Priority:** Must Have

**Description:**
Command `znav list` displays hierarchical tree view of all tracked panes organized by session and tab.

**Acceptance Criteria:**
- [x] Tree structure clear and readable
- [x] Shows session → tab → pane hierarchy
- [x] Displays metadata inline
- [x] Stale panes visually distinct

**Status:** Implemented in v1.0

---

## Non-Functional Requirements

Non-Functional Requirements (NFRs) define **how** the system performs - quality attributes and constraints.

---

### NFR-001: Command Latency

**Priority:** Must Have

**Description:**
CLI commands complete in <100ms for p95 (95th percentile) latency. Excludes LLM-powered operations.

**Acceptance Criteria:**
- [ ] `znav pane log` completes in <50ms (p95)
- [ ] `znav pane history` completes in <100ms (p95)
- [ ] `znav pane <name>` navigation completes in <100ms (p95)
- [ ] Latency measured via benchmarks in test suite
- [ ] Degradation beyond thresholds triggers alerts

**Rationale:**
CLI tools must feel instant. >100ms latency perceivable as sluggishness.

---

### NFR-002: LLM Snapshot Performance

**Priority:** Should Have

**Description:**
LLM-powered snapshot generation (`znav pane snapshot`) completes in <3s (p95).

**Acceptance Criteria:**
- [ ] Snapshot command completes in <3s in 95% of cases
- [ ] Timeout after 10s with graceful error
- [ ] Streaming responses preferred over batch
- [ ] LLM provider latency monitored

**Rationale:**
3s acceptable for automated background snapshots. Users won't wait >10s.

---

### NFR-003: History Query Performance

**Priority:** Must Have

**Description:**
History queries return results in <100ms regardless of history size (up to 100 entries per pane).

**Acceptance Criteria:**
- [ ] Query with 10 entries: <50ms
- [ ] Query with 100 entries: <100ms
- [ ] Redis LRANGE operation optimized
- [ ] Pagination available for very large histories

**Rationale:**
History queries frequent operation, must be fast.

---

### NFR-004: Secret Filtering Reliability

**Priority:** Must Have (for LLM features)

**Description:**
Secret filtering prevents 100% of configured patterns from reaching LLM. No false negatives acceptable.

**Acceptance Criteria:**
- [ ] Test suite validates all default patterns blocked
- [ ] Regex patterns compile and execute correctly
- [ ] No secrets leaked in LLM audit logs
- [ ] False positives acceptable (over-filtering safer than under-filtering)
- [ ] Filter applied before any network call

**Rationale:**
Security-critical. Single leaked secret is catastrophic failure.

---

### NFR-005: User Consent for LLM

**Priority:** Must Have

**Description:**
LLM features require explicit opt-in consent. First-run experience prompts user.

**Acceptance Criteria:**
- [ ] First `znav pane snapshot` prompts for consent
- [ ] Consent stored in config file
- [ ] Consent revokable via config or CLI command
- [ ] Clear explanation of what data sent to LLM
- [ ] No LLM calls without consent

**Rationale:**
Privacy best practice. Users must understand data sharing.

---

### NFR-006: Opt-In/Opt-Out Granularity

**Priority:** Should Have

**Description:**
Intent tracking features independently disable-able: global toggle, per-pane toggle, LLM-only toggle.

**Acceptance Criteria:**
- [ ] Config `intent_tracking.enabled = false` disables globally
- [ ] Per-pane opt-out via `--no-tracking` flag
- [ ] Config `llm_enabled = false` disables LLM, keeps manual logging
- [ ] Defaults respect privacy (opt-in, not opt-out)

**Rationale:**
Users need control over privacy vs. feature trade-offs.

---

### NFR-007: Local-Only Mode

**Priority:** Should Have

**Description:**
System fully functional without external API calls. Local-only mode disables LLM but preserves manual logging.

**Acceptance Criteria:**
- [ ] Config `llm_provider = "none"` disables all LLM features
- [ ] Local-only mode documented clearly
- [ ] No network calls in local-only mode (testable via mock)
- [ ] Warning if user attempts LLM features in local-only mode

**Rationale:**
Support privacy-conscious users and air-gapped environments.

---

### NFR-008: State Persistence Across Restarts

**Priority:** Must Have

**Description:**
All pane metadata and intent history survive Zellij crashes, system reboots, Redis restarts.

**Acceptance Criteria:**
- [ ] Intent history persists after Zellij restart
- [ ] Pane metadata persists after system reboot
- [ ] Redis AOF or RDB persistence enabled
- [ ] Graceful recovery if Redis data corrupted
- [ ] Test suite validates persistence

**Rationale:**
Core value proposition. Lost context defeats purpose.

---

### NFR-009: Graceful LLM Failure Handling

**Priority:** Must Have

**Description:**
LLM provider failures (network, quota, downtime) handled gracefully. System falls back to manual logging.

**Acceptance Criteria:**
- [ ] Network failures logged, do not crash
- [ ] API quota exceeded shows helpful error
- [ ] Timeout errors retryable manually
- [ ] Manual logging always available as fallback
- [ ] LLM failures do not block navigation or core features

**Rationale:**
External API dependency must not make system brittle.

---

### NFR-010: No Shell Performance Degradation

**Priority:** Must Have

**Description:**
Shell hooks add <10ms overhead to prompt rendering. No perceivable slowness.

**Acceptance Criteria:**
- [ ] Hook execution time <10ms (p95)
- [ ] Async execution does not block prompt
- [ ] Failed hooks do not delay prompt
- [ ] Benchmark validates no regression
- [ ] Hooks disable-able if performance issues occur

**Rationale:**
Shell hooks run on every command. Must be invisible.

---

### NFR-011: Scalability to 100+ Panes

**Priority:** Should Have

**Description:**
System performs well with 100 active panes per session. Redis queries remain fast.

**Acceptance Criteria:**
- [ ] `znav list` with 100 panes renders in <200ms
- [ ] History queries unaffected by pane count
- [ ] Redis memory usage scales linearly (~25KB per pane)
- [ ] No O(n²) algorithms in hot paths

**Rationale:**
Power users may have many long-lived panes.

---

### NFR-012: Intent History Scalability

**Priority:** Should Have

**Description:**
Individual pane histories support up to 100 entries without performance loss.

**Acceptance Criteria:**
- [ ] 100-entry history query in <100ms
- [ ] Redis LIST operations efficient at this scale
- [ ] Pagination available if histories exceed 100
- [ ] Optional auto-trim to last N entries

**Rationale:**
100 entries = ~3 months of active work at 1 entry/day.

---

### NFR-013: Storage Efficiency

**Priority:** Should Have

**Description:**
Typical user (100 panes, 50 entries each) consumes <5MB Redis storage.

**Acceptance Criteria:**
- [ ] 100 panes * 50 entries * 500 bytes = ~2.5MB
- [ ] Metadata overhead <50%
- [ ] Compression available for large histories
- [ ] Storage monitoring command available

**Rationale:**
Redis in-memory storage is costly. Efficiency matters.

---

### NFR-014: Modular Rust Architecture

**Priority:** Must Have

**Description:**
Codebase organized into modules with clear separation: CLI, State, Driver, Orchestrator, LLM.

**Acceptance Criteria:**
- [ ] Each module has single responsibility
- [ ] Module interfaces well-defined
- [ ] New features isolated to relevant modules
- [ ] Modules testable independently
- [ ] Minimal coupling between modules

**Rationale:**
Maintainability critical for long-term evolution.

---

### NFR-015: Comprehensive Error Handling

**Priority:** Must Have

**Description:**
All errors handled with anyhow crate. Error messages helpful, suggest remediation.

**Acceptance Criteria:**
- [ ] No panics in normal usage (only bugs)
- [ ] Error messages include context (what failed, why)
- [ ] Actionable suggestions where applicable
- [ ] Error codes consistent
- [ ] Errors logged appropriately

**Rationale:**
Good error UX prevents frustration and support burden.

---

### NFR-016: Backwards Compatibility with v1.0

**Priority:** Must Have

**Description:**
v2.0 intent tracking features add new Redis keys. Existing `perth:pane:<name>` schema unchanged except for one added field (`last_intent`).

**Acceptance Criteria:**
- [ ] v1.0 users can upgrade without migration
- [ ] New field addition backwards compatible
- [ ] Legacy `znav:*` keyspace migrated to `perth:*`
- [ ] Migration script provided and tested

**Rationale:**
Breaking changes unacceptable for infrastructure tool.

---

### NFR-017: Human-Readable Default Output

**Priority:** Must Have

**Description:**
Default output formats optimized for human reading: timestamps, formatting, color-coding.

**Acceptance Criteria:**
- [ ] Timestamps in local timezone
- [ ] Relative time display ("2 hours ago")
- [ ] Color-coded by entry type (milestones highlighted)
- [ ] Readable line wrapping for long summaries
- [ ] Clear visual hierarchy in tree views

**Rationale:**
Primary users are humans, not scripts. Optimize for them first.

---

### NFR-018: Machine-Readable JSON Option

**Priority:** Must Have

**Description:**
JSON output available for scripting and integration. Schema stable and versioned.

**Acceptance Criteria:**
- [ ] All commands support `--format json`
- [ ] JSON schema documented
- [ ] Schema version field included
- [ ] Stable schema (no breaking changes without major version bump)
- [ ] JSON parseable by standard tools (jq, Python, etc.)

**Rationale:**
Scripting and integration require stable machine-readable format.

---

### NFR-019: Comprehensive Help Documentation

**Priority:** Must Have

**Description:**
Every command has `--help` output with examples. README and docs provide tutorials.

**Acceptance Criteria:**
- [ ] `znav --help` shows all commands
- [ ] `znav pane --help` shows pane subcommands and examples
- [ ] README includes quickstart guide
- [ ] Docs include common workflows and patterns
- [ ] Error messages reference relevant help sections

**Rationale:**
Good documentation reduces friction and support burden.

---

### NFR-020: Zellij Version Compatibility

**Priority:** Must Have

**Description:**
Support Zellij v0.39.0 and later. Degrade gracefully on older versions with clear error.

**Acceptance Criteria:**
- [ ] Version check on startup
- [ ] Clear error if Zellij too old
- [ ] Feature compatibility matrix documented
- [ ] CI tests against multiple Zellij versions

**Rationale:**
Zellij evolving quickly. Version compatibility critical.

---

### NFR-021: Shell Environment Support

**Priority:** Should Have

**Description:**
Shell hooks work with zsh, bash, fish. Documented installation for each.

**Acceptance Criteria:**
- [ ] Zsh hook tested and documented
- [ ] Bash hook tested and documented
- [ ] Fish hook tested and documented
- [ ] Hook installation scripts provided
- [ ] Shell detection automatic where possible

**Rationale:**
Different users prefer different shells.

---

### NFR-022: Multiple LLM Provider Support

**Priority:** Should Have

**Description:**
Support Claude, GPT, and local models via configurable provider. Plugin architecture for future providers.

**Acceptance Criteria:**
- [ ] Config `llm_provider = "anthropic"` uses Claude API
- [ ] Config `llm_provider = "openai"` uses GPT API
- [ ] Config `llm_provider = "local"` uses local model
- [ ] Provider interface well-defined for extensibility
- [ ] Provider-specific config (API keys, endpoints, etc.)

**Rationale:**
Avoid vendor lock-in. Support user preferences.

---

## Epics

Epics are logical groupings of related functionality that will be broken down into user stories during sprint planning (Phase 4).

Each epic maps to multiple functional requirements and will generate 2-10 stories.

---

### EPIC-001: v1.0 Navigation Primitives

**Priority:** Must Have

**Description:**
Redis-backed pane-first navigation with metadata support, reconciliation, and tree visualization. Provides foundation for cognitive context features.

**Functional Requirements:**
- FR-020 (Pane-first navigation)
- FR-021 (Redis state persistence)
- FR-022 (Auto-focus via position tracking)
- FR-023 (Metadata attachment)
- FR-024 (Reconciliation)
- FR-025 (Tree visualization)

**Non-Functional Requirements:**
- NFR-001 (Command latency)
- NFR-008 (State persistence)
- NFR-014 (Modular architecture)
- NFR-016 (Backwards compatibility)
- NFR-020 (Zellij version support)

**Story Count Estimate:** 8-10 stories

**Status:** ✅ Implemented in v1.0

**Business Value:**
Foundation layer for all cognitive context features. Enables deterministic session management and persistent state across Zellij lifecycles.

---

### EPIC-002: Manual Intent Logging

**Priority:** Must Have

**Description:**
CLI commands for manual intent recording, history querying, classification, and artifact tracking. Establishes intent history data model and user workflows.

**Functional Requirements:**
- FR-001 (Manual intent logging)
- FR-002 (Intent history retrieval)
- FR-003 (Intent entry classification)
- FR-004 (Artifact tracking)
- FR-005 (Multiple output formats)

**Non-Functional Requirements:**
- NFR-001 (Command latency <50ms for logging)
- NFR-003 (History query performance)
- NFR-017 (Human-readable output)
- NFR-018 (Machine-readable JSON)
- NFR-019 (Help documentation)

**Story Count Estimate:** 5-7 stories

**Business Value:**
Enables developers to record cognitive context manually. Validates intent history data model and UX before investing in automation. Critical MVP feature.

**Implementation Phase:** Phase 1

---

### EPIC-003: Automated Context Capture

**Priority:** Should Have

**Description:**
LLM-powered auto-summarization from shell history and git diff. Shell hook integration for passive tracking. Secret filtering and privacy controls.

**Functional Requirements:**
- FR-006 (LLM auto-summarization)
- FR-007 (Shell hook integration)
- FR-008 (Secret pattern filtering)
- FR-009 (Local model fallback)
- FR-010 (Configurable snapshot triggers)

**Non-Functional Requirements:**
- NFR-002 (LLM snapshot performance <3s)
- NFR-004 (Secret filtering reliability)
- NFR-005 (User consent for LLM)
- NFR-006 (Opt-in/opt-out controls)
- NFR-007 (Local-only mode)
- NFR-009 (Graceful LLM failure)
- NFR-010 (No shell performance degradation)
- NFR-022 (Multiple LLM provider support)

**Story Count Estimate:** 8-10 stories

**Business Value:**
Reduces manual overhead by automating context capture. Makes intent tracking viable for daily use. Differentiates Perth from manual note-taking.

**Implementation Phase:** Phase 2

---

### EPIC-004: Agent Integration

**Priority:** Should Have

**Description:**
Jelmore integration for agent checkpoint recording, context recovery, and Bloodbank event publishing. Enables agent continuity across sessions.

**Functional Requirements:**
- FR-011 (Context recovery API)
- FR-012 (Bloodbank event publishing)
- FR-013 (Agent checkpoint recording)
- FR-014 (Session resumption context)

**Non-Functional Requirements:**
- NFR-003 (Fast history queries for context recovery)
- NFR-011 (Scalability to 100+ panes for multi-agent workflows)
- NFR-018 (JSON output for programmatic access)

**Story Count Estimate:** 6-8 stories

**Business Value:**
Critical for 33GOD agentic workflows. Enables Jelmore-spawned agents to maintain continuity across interruptions. Unlocks multi-agent coordination patterns.

**Implementation Phase:** Phase 3

**Dependencies:**
- Jelmore v2.0+ with Bloodbank integration
- Bloodbank event bus operational

---

### EPIC-005: Advanced Intelligence

**Priority:** Could Have

**Description:**
Semantic search, goal tracking, pattern recognition, visualization, and export. Intelligence layer on top of intent history for enhanced productivity insights.

**Functional Requirements:**
- FR-015 (Semantic search)
- FR-016 (Goal state tracking)
- FR-017 (Pattern recognition)
- FR-018 (Dashboard visualization)
- FR-019 (Export to Markdown/Obsidian)

**Non-Functional Requirements:**
- NFR-012 (Scalability to 100 entries for pattern analysis)
- NFR-013 (Storage efficiency with vector embeddings)

**Story Count Estimate:** 10-12 stories

**Business Value:**
Transforms intent history from passive record to active intelligence. Surfaces insights, automates retrospectives, enables data-driven workflow optimization.

**Implementation Phase:** Phase 4

**Dependencies:**
- Vector database integration (Qdrant or Chroma)
- Holocene dashboard v2.0 with timeline widget support

---

## User Stories (High-Level)

User stories follow the format: "As a [user type], I want [goal] so that [benefit]."

These are preliminary stories. Detailed stories will be created in Phase 4 (Implementation).

---

### EPIC-001: v1.0 Navigation Primitives

1. As a developer, I want to create named panes that persist across sessions so that my workspace organization survives restarts.

2. As a developer, I want to navigate to panes by name instead of position so that I can focus on tasks, not terminal geometry.

3. As a developer, I want to attach metadata to panes (project, task ID, etc.) so that I can enrich context beyond just names.

---

### EPIC-002: Manual Intent Logging

1. As a developer, I want to record what I accomplished in a work session so that I can resume context later.

2. As a developer, I want to classify entries as milestones vs. checkpoints so that I can distinguish major progress from minor updates.

3. As a developer, I want to attach file paths to intent entries so that I know which code relates to which work.

4. As a developer, I want to query my intent history as JSON so that I can build custom scripts and integrations.

---

### EPIC-003: Automated Context Capture

1. As a developer, I want Perth to automatically summarize my work from shell history so that I don't have to manually log every checkpoint.

2. As a developer, I want secrets filtered from summaries so that I can safely use LLM features without leaking credentials.

3. As a developer, I want to use a local LLM for privacy so that no context leaves my machine.

4. As a developer, I want shell hooks to trigger snapshots periodically so that context capture is passive and effortless.

---

### EPIC-004: Agent Integration

1. As a Jelmore agent, I want to record checkpoints during task execution so that my progress is observable.

2. As a Jelmore agent, I want to query previous session context when resuming work so that I can continue seamlessly.

3. As a Yi orchestrator, I want milestone events published to Bloodbank so that I can track team progress in real-time.

4. As a developer, I want to see the last intent when navigating to a pane so that I remember what I was working on.

---

### EPIC-005: Advanced Intelligence

1. As a developer, I want to search across all my work sessions semantically so that I can find related work from weeks ago.

2. As a developer, I want to declare goals and track progress automatically so that I know how close I am to completion.

3. As a team lead, I want to see recurring patterns in work so that I can optimize team workflows and identify blockers.

4. As a developer, I want to export my work narrative to Markdown so that I can journal my progress.

5. As a team member, I want to visualize session timelines in Holocene so that I can understand distributed work across the team.

---

## User Personas

### Persona 1: Solo Developer

**Name:** Alex
**Role:** Full-stack engineer
**Context:** Works on multiple projects simultaneously, frequent context switches due to meetings, Slack interruptions, and firefighting.

**Pain Points:**
- Loses 2-5 minutes reconstructing context after interruptions
- Forgets what was being debugged when returning to suspended work
- Git log unhelpful for non-code work (installations, config, debugging)

**Goals:**
- Resume work instantly with no mental overhead
- Track progress across multiple projects
- Reduce cognitive load from context switching

**How Perth Helps:**
- Query `znav pane history` to remember "where was I?"
- Auto-snapshots capture work passively
- Linear narrative easier to parse than git log

---

### Persona 2: AI Agent (Jelmore-spawned)

**Name:** CodeAgent-001
**Role:** Autonomous coding agent executing tasks from Yi orchestrator
**Context:** Spawned in Zellij pane, works for 2-4 hours, may be paused/resumed across days.

**Pain Points:**
- No memory of previous session state after restart
- Cannot explain progress to Yi orchestrator
- Context recovery requires re-reading entire codebase

**Goals:**
- Maintain continuity across restarts
- Report progress milestones automatically
- Resume work without re-analyzing everything

**How Perth Helps:**
- Context recovery API provides narrative history for resumption
- Milestone recording publishes progress to Bloodbank
- Agent checkpoints differentiated from human work

---

### Persona 3: Team Member (Handoff Scenario)

**Name:** Sam
**Role:** Backend engineer on distributed team
**Context:** Takes over work from teammate in different timezone. No overlap for live handoff.

**Pain Points:**
- Slack messages incomplete or missing context
- Git commits focused on code, not intent
- Must DM teammate with questions, delays work

**Goals:**
- Understand what was being worked on
- Continue seamlessly without blocking teammate
- Reduce handoff friction

**How Perth Helps:**
- Shared pane history provides narrative handoff
- Milestones highlight key accomplishments
- Artifacts show which files are relevant

---

### Persona 4: Power User (Multi-Agent Coordinator)

**Name:** Jordan
**Role:** Yi orchestrator managing 5-10 parallel agent tasks
**Context:** Coordinates multiple Jelmore agents working on related features. Needs visibility into all work streams.

**Pain Points:**
- Cannot track progress across distributed agents
- No single source of truth for "what's happening?"
- Agents lack coordination (duplicate work, conflicts)

**Goals:**
- Real-time visibility into all agent progress
- Identify blockers and bottlenecks quickly
- Coordinate handoffs between agents

**How Perth Helps:**
- Bloodbank events stream milestones to dashboard
- Semantic search finds related work across panes
- Goal tracking estimates completion times

---

## User Flows

### Flow 1: Solo Developer - Session Resumption

**Scenario:** Developer returns to work after weekend, forgot what was being debugged on Friday.

**Steps:**
1. Developer runs `znav pane backend-dev` to navigate to pane
2. Perth displays last intent: "Debugging token refresh flow, isolated cache invalidation issue"
3. Developer runs `znav pane history backend-dev --last 5` to see recent work
4. History shows:
   - Friday 16:00 - "Debugging token refresh flow, isolated cache invalidation issue"
   - Friday 14:00 - "Integrated OAuth library, added login endpoint"
   - Thursday 17:30 - "Set up OAuth flow skeleton"
5. Developer immediately recalls context and continues debugging cache issue
6. After fixing bug, runs `znav pane log backend-dev "Fixed cache invalidation in token refresh" --type milestone`

**Time saved:** 2-5 minutes vs. manual reconstruction

---

### Flow 2: AI Agent - Context Recovery

**Scenario:** Jelmore agent paused mid-task on Friday, resumes Monday after Zellij restart.

**Steps:**
1. Yi orchestrator requests task resumption from Jelmore
2. Jelmore queries: `znav pane history task-T-123 --format context`
3. Perth returns formatted narrative:
   ```
   Previous work on task-T-123:
   - Set up OAuth flow skeleton (3 days ago)
   - Implemented token generation and validation (2 days ago)
   - Started debugging token refresh issue (Friday 16:00)

   Last checkpoint: "Isolated cache invalidation bug in refresh endpoint"
   Artifacts: src/auth/tokens.py, src/cache/redis.py, tests/test_auth.py

   Suggested next step: Complete fix for cache invalidation bug
   ```
4. Jelmore injects narrative into agent prompt
5. Agent resumes work with full context, no re-analysis needed
6. Agent completes fix, records: `znav pane log task-T-123 "Fixed cache invalidation, all tests passing" --type milestone --source agent`
7. Milestone published to Bloodbank, Yi orchestrator notified

**Time saved:** 10-15 minutes vs. codebase re-analysis

---

### Flow 3: Team Handoff

**Scenario:** Developer A starts feature Friday, hands off to Developer B Monday (no overlap).

**Steps:**
1. Developer A works on feature, records milestones:
   ```
   znav pane feature-xyz "Refactored user model, added validation layer" --type milestone
   znav pane feature-xyz "Updated tests to match new schema"
   ```
2. Developer A EOD Friday, leaves work in pane without explicit handoff
3. Developer B starts Monday, runs: `znav pane feature-xyz`
4. Perth shows: "Last intent (2 days ago): Updated tests to match new schema"
5. Developer B runs: `znav pane history feature-xyz`
6. History shows full context of Friday's work
7. Developer B continues work immediately without Slack questions
8. Developer B adds: `znav pane log feature-xyz "Added API endpoints for new user model" --type milestone`

**Time saved:** 15-30 minutes vs. Slack back-and-forth + git archaeology

---

### Flow 4: Power User - Multi-Agent Coordination

**Scenario:** Yi orchestrator managing 3 agents working on related features in parallel.

**Steps:**
1. Yi spawns 3 Jelmore agents:
   - Agent A: `task-frontend` (UI for user management)
   - Agent B: `task-backend` (API for user management)
   - Agent C: `task-database` (Schema for user management)
2. Each agent records checkpoints:
   ```
   Agent A: "Created user list component"
   Agent B: "Implemented GET /users endpoint"
   Agent C: "Added users table migration"
   ```
3. Yi queries progress: `znav search "user management"`
4. Perth semantic search returns ranked results:
   - `task-backend`: "Implemented GET /users endpoint" (similarity: 0.95)
   - `task-frontend`: "Created user list component" (similarity: 0.92)
   - `task-database`: "Added users table migration" (similarity: 0.89)
5. Yi identifies Agent B ahead of Agent C (API ready, but schema not deployed)
6. Yi adjusts task priorities via Bloodbank commands
7. All milestones visible in Holocene dashboard timeline
8. Team lead sees real-time progress without manual check-ins

**Time saved:** Continuous visibility eliminates standup overhead

---

## Dependencies

### Internal Dependencies

**Zellij v0.39.0+:**
- Terminal multiplexer providing pane/tab/session primitives
- Perth invokes via `zellij action` CLI
- Dependency: `dump-layout` command for reconciliation

**Redis v6.0+:**
- In-memory data store for pane metadata and intent history
- Perth uses hash, list, and string data types
- Dependency: AOF/RDB persistence for durability

**Bloodbank (33GOD Event Bus):**
- Event publishing for milestone notifications
- Optional dependency (graceful degradation if unavailable)
- Used by: FR-012 (Bloodbank event publishing)

**Jelmore (33GOD Session Orchestrator):**
- Consumers of Perth API for agent session management
- Optional dependency (Perth standalone functional)
- Integration: FR-011, FR-013, FR-014

**Holocene (33GOD Dashboard):**
- Visualization consumer for session timelines
- Optional dependency (Perth CLI functional without dashboard)
- Integration: FR-018 (dashboard visualization)

---

### External Dependencies

**Claude API (Anthropic):**
- LLM provider for auto-summarization (FR-006)
- Optional dependency (local model fallback available)
- Cost: ~$0.003 per snapshot
- Requires: API key via env var `ANTHROPIC_API_KEY`

**OpenAI API:**
- Alternative LLM provider
- Optional dependency (configurable provider)
- Cost: ~$0.002 per snapshot

**Ollama / llama.cpp:**
- Local LLM provider for privacy mode
- Optional dependency (degrades to manual logging if unavailable)
- Requires: Local model installed and running

**Git v2.0+:**
- Version control for artifact tracking and diff analysis
- Optional dependency (Perth works without git, but features degraded)
- Used by: FR-006 (git diff analysis in snapshots)

**Vector Database (Qdrant or Chroma):**
- Semantic search backend for FR-015
- Optional dependency (Phase 4 feature only)
- Used by: FR-015 (semantic search)

---

## Assumptions

1. **Redis Available:**
   - Assumption: Redis server accessible at configured URL
   - Impact if false: Perth non-functional without Redis
   - Mitigation: Local Redis bundled with Perth in future version

2. **Zellij CLI in PATH:**
   - Assumption: `zellij` command executable from shell
   - Impact if false: Perth cannot invoke Zellij actions
   - Mitigation: Version check on startup, clear error message

3. **Shell History Enabled:**
   - Assumption: Users have shell history enabled (default in most shells)
   - Impact if false: Auto-snapshots less useful (no command context)
   - Mitigation: Manual logging still works

4. **Users Want Context Tracking:**
   - Assumption: Cognitive context recovery valuable enough to justify overhead
   - Impact if false: Low adoption, wasted development effort
   - Validation: User interviews, alpha/beta testing

5. **LLM Quality Sufficient:**
   - Assumption: Claude/GPT can generate accurate summaries from shell history
   - Impact if false: Auto-snapshots produce poor-quality summaries
   - Validation: Prompt engineering iteration, user feedback

6. **Privacy Concerns Manageable:**
   - Assumption: Secret filtering + opt-in consent addresses privacy concerns
   - Impact if false: Users refuse LLM features, limiting value
   - Validation: Security audit, privacy policy review

7. **Performance Acceptable:**
   - Assumption: <3s for LLM snapshots acceptable for background operations
   - Impact if false: Auto-snapshots feel sluggish, disabled by users
   - Validation: Performance benchmarks, user testing

8. **Jelmore Adoption:**
   - Assumption: Jelmore will integrate Perth for agent sessions
   - Impact if false: Agent integration features unused
   - Mitigation: Direct user engagement with Jelmore maintainers

---

## Out of Scope

**Explicitly NOT included in v2.0:**

1. **Cross-Session Pane Migration:**
   - Rationale: Complex edge cases, unclear UX
   - Future consideration: v2.5 if demand validated

2. **Multi-User Collaboration:**
   - Rationale: Requires real-time sync, conflict resolution
   - Future consideration: v3.0 with CRDT-based state

3. **Intent History Editing:**
   - Rationale: History immutability critical for audit trail
   - Mitigation: Manual entries can be deleted, but not edited

4. **Video/Screenshot Capture:**
   - Rationale: Storage overhead excessive for intent tracking
   - Alternative: Link to external screen recording tools

5. **IDE Integration:**
   - Rationale: Out of scope for terminal-focused tool
   - Alternative: Export API for IDE plugins to consume

6. **Windows Support:**
   - Rationale: Zellij Linux/macOS only
   - Future consideration: If Zellij adds Windows support

7. **Intent History Branching:**
   - Rationale: Linear narrative model fundamental to design
   - Not planned: Intentional divergence from git's non-linear history

8. **Automatic Goal Inference:**
   - Rationale: AI-inferred goals unreliable without explicit declaration
   - Phase 4 only: Manual goal setting (FR-016)

9. **Billing/Usage Tracking:**
   - Rationale: Tool infrastructure, not SaaS product
   - Not planned: Users manage own LLM costs via API keys

10. **Mobile App:**
    - Rationale: Terminal multiplexer desktop-focused
    - Not planned: No mobile use case for Zellij

---

## Open Questions

1. **Snapshot Trigger Strategy:**
   - **Question:** Command-based (every 10 commands) vs. time-based (every 30 min)?
   - **Recommendation:** Command-based with debouncing (avoid snapshot spam during rapid commands)
   - **Owner:** Engineering Lead
   - **Deadline:** Before Phase 2 implementation

2. **History Depth Policy:**
   - **Question:** Retain 90 days, 100 entries, or unlimited with TTL?
   - **Recommendation:** 90 days OR 100 entries, whichever is less, with opt-in unlimited
   - **Owner:** Product Owner
   - **Deadline:** Before Phase 1 release (affects storage planning)

3. **Cross-Session Narrative Continuity:**
   - **Question:** Should intent history survive pane name changes or only exact name matches?
   - **Recommendation:** Exact name match only (simpler model, avoids ambiguity)
   - **Owner:** Engineering Lead
   - **Deadline:** Before Phase 1 data model finalized

4. **Artifact Tracking Method:**
   - **Question:** Git diff (code-focused) vs. file watches (all files) vs. manual (user-specified)?
   - **Recommendation:** Git diff when available, manual override via `--artifacts`, file watches Phase 4 if demand
   - **Owner:** Engineering Lead
   - **Deadline:** Before Phase 2 implementation

5. **LLM Streaming vs. Batch:**
   - **Question:** Stream LLM response for faster perceived latency or batch for simplicity?
   - **Recommendation:** Batch for MVP (Phase 2), streaming for Phase 4 optimization
   - **Owner:** Engineering Lead
   - **Deadline:** Before Phase 2 implementation

6. **Holocene Timeline Widget Priority:**
   - **Question:** Should timeline visualization block Perth v2.0 release or ship async?
   - **Recommendation:** Ship Perth v2.0 independently, timeline widget follows in Holocene v2.1
   - **Owner:** Product Owner + Holocene maintainer
   - **Deadline:** Before Phase 3 completion

7. **Vector DB Choice:**
   - **Question:** Qdrant (feature-rich, self-hosted) vs. Chroma (simpler, embeddable)?
   - **Recommendation:** Chroma for Phase 4 MVP (less ops overhead), Qdrant if scale demands
   - **Owner:** Engineering Lead
   - **Deadline:** Before Phase 4 starts (semantic search)

8. **Agent Source Validation:**
   - **Question:** How to prevent users from spoofing `--source agent`?
   - **Recommendation:** Jelmore wrapper signs agent checkpoints with HMAC, Perth validates
   - **Owner:** Jelmore maintainer + Perth Engineering Lead
   - **Deadline:** Before Phase 3 agent integration

---

## Approval & Sign-off

### Stakeholders

| Role | Name | Email | Approval Status |
|------|------|-------|----------------|
| Product Owner | delorenj | - | Pending |
| Engineering Lead | delorenj | - | Pending |
| QA Lead | - | - | Pending |
| 33GOD Ecosystem Architect | delorenj | - | Pending |

### Approval Status

- [ ] Product Owner (requirements complete and aligned with vision)
- [ ] Engineering Lead (requirements technically feasible)
- [ ] QA Lead (requirements testable and acceptance criteria clear)
- [ ] Ecosystem Architect (integration with Jelmore, Holocene, Bloodbank validated)

---

## Revision History

| Version | Date | Author | Changes |
|---------|------|--------|---------|
| 1.0 | 2026-01-04 | delorenj | Initial PRD created via BMAD methodology |

---

## Next Steps

### Phase 3: Architecture

Run `/architecture` to create system architecture based on these requirements.

The architecture will address:
- All functional requirements (25 FRs: navigation + intent tracking)
- All non-functional requirements (22 NFRs: performance, security, scalability)
- Technical stack decisions (Rust, Redis, LLM providers)
- Data models (Redis schema, IntentEntry structure)
- API design (CLI commands, Jelmore integration)
- System components (CLI, State, Driver, Orchestrator, LLM modules)

### Phase 4: Sprint Planning

After architecture is complete, run `/sprint-planning` to:
- Break 5 epics into detailed user stories (~40-50 stories estimated)
- Estimate story complexity (S/M/L/XL)
- Plan sprint iterations (Phase 1: 2-3 sprints, Phase 2: 3-4 sprints, etc.)
- Assign stories to specialized agents (TDD workflow)
- Begin implementation with automated testing

---

**This document was created using BMAD Method v6 - Phase 2 (Planning)**

*To continue: Run `/workflow-status` to see your progress and next recommended workflow.*

---

## Appendix A: Requirements Traceability Matrix

| Epic ID | Epic Name | Functional Requirements | Story Count (Est.) | Status |
|---------|-----------|-------------------------|-------------------|--------|
| EPIC-001 | v1.0 Navigation Primitives | FR-020, FR-021, FR-022, FR-023, FR-024, FR-025 | 8-10 stories | ✅ Implemented |
| EPIC-002 | Manual Intent Logging | FR-001, FR-002, FR-003, FR-004, FR-005 | 5-7 stories | Phase 1 |
| EPIC-003 | Automated Context Capture | FR-006, FR-007, FR-008, FR-009, FR-010 | 8-10 stories | Phase 2 |
| EPIC-004 | Agent Integration | FR-011, FR-012, FR-013, FR-014 | 6-8 stories | Phase 3 |
| EPIC-005 | Advanced Intelligence | FR-015, FR-016, FR-017, FR-018, FR-019 | 10-12 stories | Phase 4 |
| **TOTAL** | **5 epics** | **25 functional requirements** | **37-47 stories** | **Phased** |

---

## Appendix B: Prioritization Details

### MoSCoW Breakdown

**Functional Requirements:**
- **Must Have:** 11 FRs (44%)
  - All v1.0 features (FR-020 to FR-025): 6 FRs
  - Manual intent logging core (FR-001, FR-002, FR-003, FR-005): 4 FRs
  - Secret filtering (FR-008): 1 FR

- **Should Have:** 9 FRs (36%)
  - Automated snapshots (FR-006, FR-007, FR-009, FR-010): 4 FRs
  - Agent integration (FR-011, FR-012, FR-013, FR-014): 4 FRs
  - Artifact tracking (FR-004): 1 FR

- **Could Have:** 5 FRs (20%)
  - Advanced intelligence (FR-015 to FR-019): 5 FRs

**Non-Functional Requirements:**
- **Must Have:** 12 NFRs (55%)
  - Performance (NFR-001, NFR-003): 2 NFRs
  - Security/Privacy (NFR-004, NFR-005, NFR-008): 3 NFRs
  - Reliability (NFR-009, NFR-010): 2 NFRs
  - Architecture (NFR-014, NFR-015, NFR-016): 3 NFRs
  - Usability (NFR-017, NFR-018, NFR-019): 3 NFRs
  - Compatibility (NFR-020): 1 NFR

- **Should Have:** 10 NFRs (45%)
  - Performance (NFR-002): 1 NFR
  - Privacy (NFR-006, NFR-007): 2 NFRs
  - Scalability (NFR-011, NFR-012, NFR-013): 3 NFRs
  - Compatibility (NFR-021, NFR-022): 2 NFRs

### Priority Rationale

**Phase 1 Focus (Must Have):**
Manual logging establishes data model and validates UX. Secret filtering critical for LLM safety. v1.0 features already implemented provide foundation.

**Phase 2 Focus (Should Have):**
Automation makes intent tracking practical for daily use. LLM quality determines feature value. Privacy controls address adoption blockers.

**Phase 3 Focus (Should Have):**
Agent integration unlocks 33GOD ecosystem value. Jelmore adoption validates architectural decisions. Bloodbank events enable observability.

**Phase 4 Focus (Could Have):**
Intelligence features enhance but not required for core value prop. Semantic search, visualization, pattern recognition provide advanced insights.

**Not Included (Won't Have):**
Cross-session migration, multi-user collaboration, IDE integration deferred to future versions or out of scope entirely (see "Out of Scope" section).

---

## Appendix C: Success Criteria Summary

**MVP Success (Phase 1):**
- 10+ alpha users adopt manual intent logging
- >70% of manual summaries rated useful
- No Redis performance degradation with 100 panes

**v2.0 Success (Phase 2):**
- 50+ beta users enable auto-snapshots
- >80% of automated summaries rated useful
- <$5/month LLM costs per power user

**v2.5 Success (Phase 3):**
- Jelmore integrates Perth for all agent sessions
- >90% agent context recovery accuracy
- Bloodbank events powering Holocene timeline

**v3.0 Success (Phase 4):**
- Semantic search used by 30% of active users
- Pattern recognition identifies >5 workflow optimizations
- Dashboard visualization drives team coordination

---

**End of PRD**
